# Skynet 游戏服务器框架完整架构分析

> 本文档包含了 Skynet 框架的深度架构分析、设计原理和可视化图表，为开发者提供全面的技术参考。

## 目录

- [1. 架构概述](#1-架构概述)
- [2. 核心设计理念](#2-核心设计理念)
- [3. 整体架构设计](#3-整体架构设计)
- [4. 核心组件详解](#4-核心组件详解)
- [5. 并发模型与调度](#5-并发模型与调度)
- [6. 网络架构设计](#6-网络架构设计)
- [7. 服务管理机制](#7-服务管理机制)
- [8. 集群与分布式](#8-集群与分布式)
- [9. 性能优化策略](#9-性能优化策略)
- [10. 架构图表集](#10-架构图表集)
- [11. 最佳实践](#11-最佳实践)
- [12. 总结](#12-总结)

---

## 1. 架构概述

Skynet 是一个基于 Actor 模型的轻量级游戏服务器框架，由云风设计开发。它采用 C + Lua 的双层架构，底层 C 提供高性能的消息调度和网络管理，上层 Lua 实现灵活的业务逻辑。

### 关键特性

- **Actor 模型**：每个服务都是独立的 Actor，通过消息通信
- **高并发**：支持数万个轻量级服务同时运行
- **高性能**：C 语言底层，无锁设计，零拷贝优化
- **易扩展**：模块化架构，支持热更新
- **分布式**：内置集群支持，透明的远程调用

### 技术栈

| 层次 | 技术 | 说明 |
|------|------|------|
| 底层 | C | 核心引擎，消息队列，网络 I/O |
| 脚本层 | Lua 5.4.7 | 业务逻辑，服务实现 |
| 内存管理 | jemalloc | 高效内存分配 |
| 网络 | epoll/kqueue | 高性能事件驱动 |
| 协议 | sproto | 二进制序列化协议 |

## 2. 核心设计理念

### 2.1 Actor 模型

Skynet 严格遵循 Actor 模型的设计原则：

1. **封装性**：每个 Actor（服务）拥有独立的状态
2. **并发性**：Actor 之间并发执行，互不干扰
3. **消息传递**：Actor 之间只能通过异步消息通信
4. **无共享**：禁止共享内存，避免锁竞争

### 2.2 设计哲学

- **简单即美**：用最简单的方式解决复杂问题
- **约束即自由**：强制消息传递带来架构清晰
- **隔离优于共享**：服务隔离保证系统稳定性
- **异步非阻塞**：提高系统吞吐量

## 3. 整体架构设计

### 3.1 分层架构

```
┌──────────────────────────────────────────┐
│          业务应用层（Business）            │
│    游戏逻辑、Web服务、自定义业务           │
├──────────────────────────────────────────┤
│         系统服务层（Services）             │
│    bootstrap、launcher、gate、logger      │
├──────────────────────────────────────────┤
│          Lua-C 桥接层（Bridge）           │
│    skynet.lua、snax、sproto              │
├──────────────────────────────────────────┤
│          C 核心运行时（Runtime）           │
│    消息队列、服务管理、网络、定时器         │
├──────────────────────────────────────────┤
│           操作系统层（OS）                 │
│    Linux、macOS、FreeBSD                  │
└──────────────────────────────────────────┘
```

### 3.2 模块组成

#### C 核心模块
- **skynet_main.c**：主入口，配置加载，系统启动
- **skynet_start.c**：启动管理，线程创建
- **skynet_server.c**：服务管理，消息分发
- **skynet_mq.c**：消息队列实现
- **skynet_handle.c**：服务句柄管理
- **skynet_socket.c**：Socket 封装层
- **socket_server.c**：底层网络实现
- **skynet_timer.c**：定时器系统
- **skynet_monitor.c**：监控和死循环检测

#### Lua 核心模块
- **skynet.lua**：核心 API 封装
- **bootstrap.lua**：系统启动脚本
- **launcher.lua**：服务启动器
- **console.lua**：调试控制台
- **gate.lua**：网关服务

## 4. 核心组件详解

### 4.1 服务上下文（skynet_context）

```c
struct skynet_context {
    void * instance;              // 服务实例数据
    struct skynet_module * mod;   // 服务模块
    skynet_cb cb;                // 消息回调函数
    struct message_queue *queue;  // 专属消息队列
    uint32_t handle;             // 唯一服务 ID
    int session_id;              // 会话管理
    ATOM_INT ref;               // 引用计数
    bool endless;               // 死循环检测标记
    char result[32];            // 返回值缓冲区
};
```

**关键机制：**
- **服务 ID 分配**：24 位本地 ID + 8 位 harbor ID
- **引用计数管理**：确保服务安全释放
- **消息回调注册**：支持 C 和 Lua 两种回调

### 4.2 消息队列（Message Queue）

#### 双层队列架构

```
全局队列（Global Queue）
    │
    ├─→ 服务队列 A ─→ [消息1][消息2][消息3]...
    ├─→ 服务队列 B ─→ [消息1][消息2]...
    └─→ 服务队列 C ─→ [消息1]...
```

#### 消息结构

```c
struct skynet_message {
    uint32_t source;      // 消息源
    int session;         // 会话 ID
    void * data;        // 消息数据
    size_t sz;         // 数据大小
};
```

#### 队列特性
- **动态扩容**：初始 64，按需翻倍
- **过载保护**：超过 1024 条消息警告
- **无锁出队**：单消费者模式
- **批量处理**：工作线程批量获取消息

### 4.3 句柄管理（Handle Management）

```c
// 句柄结构：8位 harbor + 8位 高位 + 8位 低位
// 例如：0x01020304 
//   01 = harbor id
//   02 = 高8位
//   0304 = 低16位

struct handle_storage {
    struct skynet_context **slot;  // 哈希表槽位
    uint32_t mod;                  // 槽位数量-1（用于掩码）
    uint32_t count;                // 服务数量
    int init;                      // 初始化标志
    uint32_t index;               // 下一个分配索引
};
```

### 4.4 定时器系统（Timer System）

#### 分层时间轮算法

```c
struct timer {
    struct link_list near[256];    // 近期轮（2.56秒）
    struct link_list t[4][64];     // 4层分层轮
    struct spinlock lock;          // 自旋锁
    uint32_t time;                // 当前时间（10ms精度）
    uint32_t starttime;           // 启动时间
    uint64_t current;            // 当前真实时间
    uint64_t current_point;      // 当前时间点
};
```

时间范围：
- 第 0 层：0-256（2.56秒）
- 第 1 层：256-16384（约 2.7 分钟）
- 第 2 层：16384-1048576（约 2.9 小时）
- 第 3 层：1048576-67108864（约 7.7 天）
- 第 4 层：67108864-4294967296（约 497 天）

### 4.5 网络系统（Socket System）

#### Socket 池设计

```c
struct socket_server {
    struct socket pool[MAX_SOCKET];  // 65536 个槽位
    volatile uint64_t time;          // 时间戳
    int epfd;                       // epoll fd
    fd_set rfds;                   // select 集合
    int checkctrl;                 // 控制管道
    int recvctrl_fd;              // 接收管道
    int sendctrl_fd;             // 发送管道
    struct socket_message result; // 结果缓冲
};
```

#### Socket 状态机

```
INVALID → RESERVE → LISTEN → CONNECTED → HALFCLOSE → CLOSED
                 ↘          ↗
                  CONNECTING
```

## 5. 并发模型与调度

### 5.1 线程模型

| 线程类型 | 数量 | 职责 | 实现方式 |
|---------|------|------|---------|
| 监控线程 | 1 | 死循环检测，服务状态监控 | 5秒检查一次 |
| 定时器线程 | 1 | 定时器触发，时间更新 | 2.5ms精度 |
| 网络线程 | 1 | epoll/kqueue事件循环 | 边缘触发 |
| 工作线程 | N | 消息处理，服务调度 | 权重调度 |

### 5.2 工作线程调度算法

```c
// 权重机制
static int weight[] = { 
    -1,     // 每次1条消息
    -1,     // 每次1条消息
    -1,     // 每次1条消息
    -1,     // 每次1条消息
    0,      // 处理完一个队列
    0,      // 处理完一个队列
    0,      // 处理完一个队列
    0,      // 处理完一个队列
    1,      // 处理n个队列(n=1)
    1,      // 处理n个队列(n=1)
    1,      // 处理n个队列(n=1)
    1,      // 处理n个队列(n=1)
    2,      // 处理n个队列(n=2)
    2,      // 处理n个队列(n=2)
    2,      // 处理n个队列(n=2)
    3,      // 处理n个队列(n=3)
};
```

### 5.3 消息调度流程

```
1. 工作线程从全局队列获取服务队列
2. 根据权重处理消息
3. 调用服务的消息回调函数
4. 将服务队列重新加入全局队列（如果还有消息）
5. 无消息时进入休眠等待唤醒
```

## 6. 网络架构设计

### 6.1 网络层次结构

```
应用层（Application）
    ↓
Gate 网关层（Gateway）
    ↓
Socket 封装层（skynet_socket）
    ↓
Socket 服务器层（socket_server）
    ↓
系统调用层（epoll/kqueue）
```

### 6.2 Gate 网关设计

Gate 服务负责管理客户端连接，主要功能：

1. **连接管理**：接受、关闭、踢除连接
2. **协议解析**：支持多种协议格式
3. **消息路由**：将消息转发给对应的 Agent
4. **流量控制**：限制消息大小和频率

### 6.3 数据流程

```
客户端 → Socket → Gate → Agent → 业务逻辑
                    ↓
                 其他服务
```

## 7. 服务管理机制

### 7.1 服务生命周期

```
创建（Create）
    ↓
初始化（Init）
    ↓
运行（Running）
    ↓
退出（Exit）
    ↓
释放（Release）
```

### 7.2 服务启动流程

1. **加载模块**：dlopen 加载 .so 文件
2. **创建实例**：调用 module_create
3. **初始化**：调用 module_init
4. **注册回调**：设置消息处理函数
5. **加入调度**：添加到全局队列

### 7.3 Lua 服务特殊处理

- **独立 VM**：每个 Lua 服务独立的 Lua 虚拟机
- **内存限制**：可设置内存上限
- **协程调度**：每个请求创建协程
- **热更新**：支持代码热更新

## 8. 集群与分布式

### 8.1 Harbor 系统

Harbor 提供多节点互联功能：

```
节点 A (harbor=1)
    ↓↑
Harbor Master
    ↓↑
节点 B (harbor=2)
```

### 8.2 服务寻址

- **本地服务**：直接通过句柄访问
- **远程服务**：通过 harbor 转发
- **全局名字**：支持字符串名字注册

### 8.3 Cluster 集群

更高级的集群方案，支持：
- 动态添加/删除节点
- 故障检测和恢复
- 负载均衡
- 跨节点 RPC

## 9. 性能优化策略

### 9.1 内存优化

- **jemalloc**：减少内存碎片
- **对象池**：复用频繁创建的对象
- **消息零拷贝**：避免不必要的内存拷贝

### 9.2 CPU 优化

- **无锁设计**：减少锁竞争
- **批量处理**：批量获取和处理消息
- **CPU 亲和性**：绑定线程到 CPU 核心

### 9.3 I/O 优化

- **边缘触发**：epoll ET 模式
- **写缓冲合并**：合并小数据包
- **直写优化**：小数据直接发送

### 9.4 调度优化

- **工作窃取**：空闲线程窃取任务
- **自适应休眠**：动态调整休眠时间
- **优先级队列**：重要消息优先处理

## 10. 架构图表集

详细的架构可视化图表请参见：[architecture-diagrams.md](./architecture-diagrams.md)

包含的图表：
1. 整体架构图
2. 启动流程图
3. 消息传递序列图
4. 线程模型图
5. 服务生命周期图
6. 网络架构图
7. 核心组件关系图
8. 消息队列架构图
9. 定时器系统图
10. 集群架构图

## 11. 最佳实践

### 11.1 服务设计原则

1. **单一职责**：每个服务只做一件事
2. **无状态设计**：尽量设计无状态服务
3. **消息幂等**：处理消息重发和乱序
4. **优雅降级**：处理服务不可用情况

### 11.2 性能调优建议

1. **合理设置线程数**：CPU 核心数的 1-2 倍
2. **控制服务数量**：避免创建过多服务
3. **批量处理**：合并多个小消息
4. **异步 I/O**：避免阻塞操作

### 11.3 常见陷阱

1. **死循环**：避免在消息处理中死循环
2. **内存泄漏**：正确管理 Lua 内存
3. **消息堆积**：监控队列长度
4. **热点服务**：避免单点瓶颈

## 12. 总结

### 12.1 架构优势

- **简洁优雅**：代码精简，易于理解
- **高性能**：C 底层，无锁设计
- **高并发**：轻量级服务，支持数万并发
- **易扩展**：模块化设计，支持热更新
- **成熟稳定**：经过大量商业项目验证

### 12.2 适用场景

**最适合：**
- MMORPG 游戏服务器
- 实时对战游戏
- 即时通讯系统
- 物联网后端

**不适合：**
- CPU 密集型计算
- 大数据处理
- 简单 CRUD 应用

### 12.3 架构评分

| 维度 | 评分 | 说明 |
|------|------|------|
| 可扩展性 | 9/10 | 优秀的模块化设计 |
| 性能 | 9/10 | 高性能 C 核心 |
| 可维护性 | 8/10 | 代码清晰但调试较难 |
| 可靠性 | 9/10 | 经过实战检验 |
| 学习曲线 | 7/10 | 需要理解 Actor 模型 |

### 12.4 发展展望

Skynet 作为一个成熟的游戏服务器框架，在未来可以考虑：

1. **多核优化**：更好的 NUMA 支持
2. **云原生**：容器化和 K8s 集成
3. **监控增强**：分布式追踪和度量
4. **生态完善**：更多的工具和中间件

---

> **文档版本**：1.0  
> **更新日期**：2024  
> **作者**：架构分析团队  
> **协助**：Claude AI Assistant

## 参考资料

- [Skynet GitHub](https://github.com/cloudwu/skynet)
- [Skynet Wiki](https://github.com/cloudwu/skynet/wiki)
- [云风的博客](https://blog.codingnow.com)